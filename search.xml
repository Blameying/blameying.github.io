<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rCore实验-虚拟地址到物理地址转换</title>
      <link href="/2022/08/15/rCore%E5%AE%9E%E9%AA%8C-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"/>
      <url>/2022/08/15/rCore%E5%AE%9E%E9%AA%8C-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>最近在看<a href="https://github.com/LearningOS">rCore操作系统</a>实验，在做到虚拟地址到物理地址转换这一部分花的时间比较多。之前主要是从CPU的角度去理解MMU如何进行虚拟地址到物理地址的转换，多级页表是如何寻找的，知道应该有这么一个页表专门存储下一级页表的地址数组，但是一开始的时候由于没有通读源码，所以一直没找到这部分。所以细读了一下rCore实验在lab4_ref给出的mm部分的代码，主要是带着两个问题读的：</p><ol><li>在satp(Supervisor Address Translation and Protection，监管者地址转换和保护)寄存器发生地址模式切换以后，内核代码中对原来实地址模式下的数据的访问如何继续生效</li><li>OS视角构建页表索引的细节</li></ol><p>在<a href="https://github.com/LearningOS/rust-based-os-comp2022/tree/main/os4-ref">项目目录</a>下有以下几个部分:</p><table><thead><tr><th align="center">模块</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">mm</td><td align="center">内存管理模块</td></tr><tr><td align="center">sync</td><td align="center">多线程同步模块</td></tr><tr><td align="center">syscall</td><td align="center">系统调用模块</td></tr><tr><td align="center">task</td><td align="center">进程管理模块</td></tr><tr><td align="center">trap</td><td align="center">中断模块</td></tr></tbody></table><p>虚拟地址到物理地址的映射和管理主要在内存管理模块中，内存管理模块主要完成了以下几个功能:</p><ul><li>内核堆内存管理</li><li>页表内存分配和回收</li><li>页表目录管理(虚地址到实地址的映射关系维护)</li></ul><h3 id="内核堆内存管理"><a href="#内核堆内存管理" class="headerlink" title="内核堆内存管理"></a>内核堆内存管理</h3><p>按照之前嵌入式实时系统上的经验，操作系统本身直接与硬件打交道，因此会完成“开天辟地”的过程，也就是说需要构建程序运行的环境。类似于应用程序中内存分配功能是要自己来实现的。因此，常用的做法是，通过静态全局变量数组来占据一段连续的内存空间当作堆内存的内存池。内核堆内存管理则主要是负责对这块内存池的使用进行管理。</p><p>在<a href="https://github.com/LearningOS/rust-based-os-comp2022/blob/main/os4-ref/src/mm/heap_allocator.rs">heap_allocator.rs</a>文件中主要完成了内核的堆内存分配。在正常的应用程序编写时，我们可以使用std库来完成我们在堆上的内存分配，这个操作一般是<strong>new</strong>，而在裸机环境中是没有std环境的，这种情况下可以使用<a href="https://doc.rust-lang.org/alloc/index.html">alloc</a>库，它的主要介绍如下：</p><blockquote><p>This library provides smart pointers and collections for managing heap-allocated values.</p><p>This library, like libcore, normally doesn’t need to be used directly since its contents are re-exported in the std crate. Crates that use the #![no_std] attribute however will typically not depend on std, so they’d use this crate instead.</p></blockquote><p>当使用alloc库进行分配时，可以通过 <strong>#[global_allocator]</strong> 声明将要使用的分配器，可以看到在 <strong>heap_allocator.rs</strong> 中指定了堆内存分配器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[global_allocator]</span></span><br><span class="line"><span class="comment">// heap allocator instance</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> HEAP_ALLOCATOR: LockedHeap = LockedHeap::<span class="title function_ invoke__">empty</span>();</span><br></pre></td></tr></table></figure><p>HEAP_ALLOCATOR需要实现 <strong>GlobalAlloc</strong> trait方可被alloc库正确调用，<strong>buddy-system_allocator</strong> 中的 <strong>LockedHeap</strong> 有如下实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">GlobalAlloc</span> <span class="keyword">for</span> <span class="title class_">LockedHeap</span> &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">alloc</span>(&amp;<span class="keyword">self</span>, layout: Layout) <span class="punctuation">-&gt;</span> *<span class="keyword">mut</span> <span class="type">u8</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">alloc</span>(layout)</span><br><span class="line">            .<span class="title function_ invoke__">ok</span>()</span><br><span class="line">            .<span class="title function_ invoke__">map_or</span>(<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, |allocation| allocation.<span class="title function_ invoke__">as_ptr</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dealloc</span>(&amp;<span class="keyword">self</span>, ptr: *<span class="keyword">mut</span> <span class="type">u8</span>, layout: Layout) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">dealloc</span>(NonNull::<span class="title function_ invoke__">new_unchecked</span>(ptr), layout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此内核堆内存管理主要是利用  <strong>alloc</strong> 与 <strong>buddy_system_allocator</strong> 来实现的。</p><h3 id="页表内存分配和回收"><a href="#页表内存分配和回收" class="headerlink" title="页表内存分配和回收"></a>页表内存分配和回收</h3><p>内核会管理全部的内存地址，因此除去内核所占的内存空间外，从链接脚本的 <strong>ekernel（end of kernel）</strong> 开始直到 <strong>MAX_MEMORY</strong> 都将被内核以页表的形式动态管理。这部分的代码在 <a href="https://github.com/LearningOS/rust-based-os-comp2022/blob/main/os4-ref/src/mm/frame_allocator.rs">frame_allocator.rs</a>，通过 <strong>StackFrameAllocator</strong> 来进行 <strong>stack(栈)</strong> 风格的内存管理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StackFrameAllocator</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">StackFrameAllocator</span> &#123;</span><br><span class="line">    current: <span class="type">usize</span>,</span><br><span class="line">    end: <span class="type">usize</span>,</span><br><span class="line">    recycled: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始分配内存时，会通过current的递增来实现。在有内存需要回收的时候，将其地址存入recycled列表中表示其可用，这种情况下再次收到分配内存的请求就会优先从recycled中进行分配。</p><p><strong>FrameTracker</strong> 则是内核对分配的物理页表的一个handler，可以通过它记录物理页表的物理地址，当该handler生命周期结束后，则会自动对指定的页表进行释放。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FrameTracker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">frame_dealloc</span>(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页表目录管理"><a href="#页表目录管理" class="headerlink" title="页表目录管理"></a>页表目录管理</h3><p>在拥有上一节对全部物理内存的简单分配和回收功能后，开启虚拟地址模式的最后一部分工作就是建立虚拟地址到物理地址的映射关系了。<br><img src="https://blog-img-1310827095.cos.ap-beijing.myqcloud.com/virtualAddr_to_phy.svg" alt="virtualAddr_to_phy"></p><p>如图所示，连续的虚拟地址不一定对应连续的物理地址，而这个对应关系需要操作系统按照CPU支持的格式进行维护。由虚拟地址到物理地址的转换是CPU MMU器件自动发生的硬件行为。</p><p>rCore采用的是<a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html">Sv39</a>的转换模式。与地址转换相关的寄存器为 <strong>satp</strong> 寄存器，它的布局是：<br><img src="http://rcore-os.cn/rCore-Tutorial-Book-v3/_images/satp.png" alt="satp">, 其中PPN存放的是页表的根地址，即多级页表中的第一级页表的地址。当通过页表来进行地址转换时，流程如下：</p><ol><li>通过satp中的ppn访问第一级页表的物理地址</li><li>获取该地址下，虚拟地址的第一级的偏移，找到对应的 <strong>PTE</strong> 节点信息，继而判断这个页表项指向的是下一级页表还是物理的内存页，如果是内存页则直接开始读写操作，如果仍旧不是叶结点则继续查找下一级。（关于PTE，虚拟地址和物理地址的结构信息，可以查看risc-v的<a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">特权级别架构手册</a></li></ol><p>在没有细读源码的时候，我是没找到这样一张表的，因为从来没有在操作系统的角度看过页表的使用，因此不清楚它是随着使用而不断的改变的。</p><p>这部分的源码在 <strong><a href="https://github.com/LearningOS/rust-based-os-comp2022/blob/main/os4-ref/src/mm/page_table.rs">page_table.rs</a></strong> 中，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">        <span class="title function_ invoke__">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">                result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">                <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">            &#125;</span><br><span class="line">            ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">find_pte</span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;PageTableEntry&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">        <span class="title function_ invoke__">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pte</span> = &amp;ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">                result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 <strong>find_pte_create</strong> 方法中，<strong>pte</strong> 非法时会通过上段提到的页表内存分配接口进行动态的分配，并将其物理地址 <strong>frame.ppn</strong> 写入 <strong>pte</strong> 中,而当合法时，则直接返回。</p><p>通过上述的几段分析，基本上涵盖了内核所遇到的内存方面的管理。那还有最后一个疑问是，当处理器的地址模式由实地址变为虚地址时，原来内核部分的代码如何正常运行，要知道内核中并不是所有变量用的都是相对地址，包括一些物理外设的访问地址都是固定的。</p><p>我去对比了一下带 <strong>mm</strong> 模块前的 <strong>os</strong> 实验，发现编译器方面并没有添加什么与之相关的编译参数，只能是在代码里做的手脚，发现这部分的处理在 <strong><a href="https://github.com/LearningOS/rust-based-os-comp2022/blob/main/os4-ref/src/mm/memory_set.rs">memory_set.rs</a></strong> 文件中， </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">MapType</span> &#123;</span><br><span class="line">    Identical,</span><br><span class="line">    Framed,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MapArea</span> &#123;</span><br><span class="line">    vpn_range: VPNRange,</span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了两种的虚拟地址到物理地址映射方式，其中 <strong>Framed</strong> 的方式就是前文提到的分配内存的方式，那这种虚拟地址和物理地址的映射是没有字面上的联系的，也就是不查表的情况下，是看不出关联的，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_kernel</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">    <span class="comment">// map trampoline</span></span><br><span class="line">    memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">    <span class="comment">// map kernel sections</span></span><br><span class="line">    info!(<span class="string">&quot;.text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, stext <span class="keyword">as</span> <span class="type">usize</span>, etext <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    info!(<span class="string">&quot;.rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, srodata <span class="keyword">as</span> <span class="type">usize</span>, erodata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    info!(<span class="string">&quot;.data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sdata <span class="keyword">as</span> <span class="type">usize</span>, edata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    info!(</span><br><span class="line">        <span class="string">&quot;.bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">        sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>, ebss <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .text section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (stext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (etext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::X,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .rodata section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (srodata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (erodata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .data section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (sdata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (edata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .bss section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (ebss <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping physical memory&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (ekernel <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MEMORY_END.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    memory_set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义 <strong>new_kernel</strong> 方法的时候，引用了大量的链接文件中定义的全局变量，比如 <strong>sbss,ebss,stext,etext</strong> 等，可以看到，这些已有的程序需要使用的地址都进行了 <strong>Identical</strong> 类型的映射。</p><p>在 <strong>MapArea</strong> 的 <strong>map_one</strong> 方法中，我们可以发现， <strong>Identical</strong> 是不需要再次分配内存来进行映射的，而是直接把传进来的地址作为物理地址使用，也就是说，为了保证在切换地址模式后，内核的代码仍旧能够正常工作，它用同样的虚拟地址指向了原来的物理地址，即建立了0x80000000(虚拟地址)到0x80000000(物理地址)的联系，这部分代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ppn</span>: PhysPageNum;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.map_type &#123;</span><br><span class="line">        MapType::Identical =&gt; &#123;</span><br><span class="line">            ppn = <span class="title function_ invoke__">PhysPageNum</span>(vpn.<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MapType::Framed =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            ppn = frame.ppn;</span><br><span class="line">            <span class="keyword">self</span>.data_frames.<span class="title function_ invoke__">insert</span>(vpn, frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pte_flags</span> = PTEFlags::<span class="title function_ invoke__">from_bits</span>(<span class="keyword">self</span>.map_perm.bits).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    page_table.<span class="title function_ invoke__">map</span>(vpn, ppn, pte_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DLP4500驱动乱码问题</title>
      <link href="/2022/06/17/DLP4500%E9%A9%B1%E5%8A%A8%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/06/17/DLP4500%E9%A9%B1%E5%8A%A8%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近在从官方的DLPLCR4500GUI中提取DLP4500的驱动时遇到了一些问题，由于在网上只知道了相似的问题却没有得到对应的解决方案，经过了一段时间痛苦的调试终于才找到了原因。所以在这里记录一下，能救一个是一个。</p><p>大部分人在使用DLP4500时是通过官方的客户端调试软件进行，但当我们需要进行类似双目重建之类的项目时则需要在程序中能够对其精确控制，所以我整理了他们的驱动并嵌入到自己的程序中。整个过程非常顺利，唯独在刚刚上电后投影会出现乱码问题，而使用官方封装的软件是并无此问题的。<br>于是只能通过对比函数的调用来排查，避免有某些配置项的遗漏，但是经过比较发现并无遗漏。于是猜测，可能是在传入的数据中出了问题，一定是某个操作在启动时清除了DMD中的残留数据，而我们自己的驱动没有这个操作，导致了数据叠加出现了乱码。<br>通过对DLP4500 AddPat这个操作的调试发现，官方在配置第一个数据项的时候Buf_swap选项是打开的，而后续的其他数据项都是关闭的。即在投影第一张的时候要开启buf_swap做一些类似清理的操作。</p><p>虽然结果很简单，但是排查调试的过程很痛苦，手册上并未找到对这一细节进行的说明，于是只能通过猜测-实验的过程来定位。</p>]]></content>
      
      
      <categories>
          
          <category> 那些痛苦的Bugs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>市场的局域性</title>
      <link href="/2022/04/23/%E5%B8%82%E5%9C%BA%E7%9A%84%E5%B1%80%E5%9F%9F%E6%80%A7/"/>
      <url>/2022/04/23/%E5%B8%82%E5%9C%BA%E7%9A%84%E5%B1%80%E5%9F%9F%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>最近发现世界上很多事情都遵循局域性的原理，虽然网络和快递看似将整个社会连成一片但是局域性并不表现在地域上，还发生在不同职业的，教育程度，年龄等人群的分类上。现在的创业者觉得好的机遇都已经被巨头所占领，即便是在一细分领域做的很好也扛不住资本的迅速赶超，好像世界上一旦出现新的能卖的产品，就会被其他有资源的人抢占。我觉得这是一个误区，是自我营造的恐惧。所以有了如下思考，我思考的分别是地理区域性，人群区域性，信息区域性，以及认知区域性。据国家市场监督管理总局2021年，中国的民营企业数量达到了4457.5万户，民营企业前500强的入围门槛为235亿元，这么多的企业各有各的活得益于前文提到的各个方面的局域性。</p><h4 id="地理区域性"><a href="#地理区域性" class="headerlink" title="地理区域性"></a>地理区域性</h4><p>一些线下产业呈现出明显的地理区域性特征，这一类企业的成长路线为从下到上，以影响力的地域扩张。一种是人们日常使用的生活用品，小型的加工制造业，建筑材料，以及定制化的软件需求。仅仅是点餐系统这一并无多少科技含量的产品都五花八门，每个门店有属于自己点餐系统或者使用一些小平台提供的接入服务，这些小平台之间竞争并没有那么明显，更多的是需要一点点去跑业务。那像美团这样的大企业为什么没有统一这样的线下市场呢，大家都用美团的线上点餐岂不是就没有这些小平台的生存空间了吗？大公司看上去拥有雄厚的资金和人力，但如果过度分散项目到这样的线下市场，需要很多人力来做商家的沟通和服务的话，会使得自己深陷入各类项目的漩涡，我猜大公司在项目的选择上应当也是谨慎的，如果对自己的定位不准的话，很容易大船搁浅浅滩。大船是进不了礁石丛的，但是小船可以。小型的加工制造业一般是面向企业客户的，对物流和时间有着较高的要求，同时大体量的制造业厂是没有带宽余量给小公司的，这也就是初创企业拿不到供应链的原因。所以我觉得创业的关键不是去看这个领域有哪些巨头，而是看有哪些需求是尚未被满足的，哪些客户是被搁置的，以小搏大只能先农村包围城市。其实初期各类外卖公司都是进行线下竞争的，一个一个城市的去搞代理，然后代理一个一个店铺去说服。当达到一定规模以后，才成为店家为数不多的选择之一。还有一件事情就是不要只把目光放在自己所熟知的人群，这是没有前途的，生活在中国大城市的年轻人很难理解电池容量大，带手电筒的板砖一样的弱智能机在非洲是最受欢迎的，正如卧安这样简洁小巧的产品会受到日本人的欢迎，大疆无人机这类具有冒险精神特质的产品在北美的流行程度要远超国内。每个地区的人都有自己的特质，思考方式也不同，所以创业的过程更多的是对人的认识，idea更多的是在对人充分认知后自然而然的产物。</p><h4 id="人群区域性"><a href="#人群区域性" class="headerlink" title="人群区域性"></a>人群区域性</h4><p>人群的区域性是非常复杂的，我们常说的找到目标客户其实就是要搞清楚人群的区域性。举个例子，在年轻人中几乎人人都用微博，当我告诉别人我不用的时候，其实大家是很惊讶的，但从我的角度来说，我身边的理工科男生用微博的人并没那么多。而我不用抖音，所以我不了解抖音的强大，我以为这个平台比微博弱多了，但其实不管是乡下还是周围的同学都在用抖音快手之类的短视频软件，尤其是在乡下更是火爆。喜欢文字的人和喜欢视频的简单的人，都存在。也就是说即便是我们找到一小部分人，这群人有特殊的癖好，我们把他们的需求解决就能够让我们活下去。这是人群的区域性，强如微信，微博，抖音也没办法覆盖所有人群。戴森的产品出来之前，其实市面上并不缺少吹风机和吸尘器，但它的设计戳动了小中产及高产家庭，所以能够迅速的以自己的设计取胜，我觉得它并没有建立很强的技术壁垒，但是却有自己的设计壁垒。那么，戴森做大以后，其他的吹风机还活着么？是活着的，戴森的市场只是占去了这个领域的一个小部分，甚至在小县城可能都没有听说过戴森，不同消费能力的人群对产品的需求是不一样。对于舒适的需求其实是和消费能力绑定的。很多人都觉得乒乓球发球机这个东西已经有人做了，并且做的非常好，所以不推荐后来的创业者再做这件事。我对这个市场做过一些调研，一种发球机是好几万一台的笨重机器人，只适合省队及以上的专业团队使用，但专业团队都有专业的陪练，对发球机的需求有待商榷，且发球机更多的适合初学者。而便宜的发球机又做的非常呆，基本上起不到训练的效果。所以这个市场就呈现了严重的两极分化，一种是成本很高，做的很大，一种是做的成本很低，基本不能用。如果我们能做出一定的技术突破解决这两个极端的问题，那未必未来不是我们的。所以我觉得看待问题应该辩证性的看待问题，如果一个问题没有被解决却被感知，那确实有两种可能，一种是科学角度解决不了，一种是不值得，而不管是前者还是后者，都是时间相对的。人们的需求和理念也是随着时间在变的。</p><p>当然如果大家既然决定是技术创业，那就把技术突破和技术创新当成一定要遇到的问题，甚至不遇到都不放心的那种。如果没有这种准备，那就去找到区域性里的不饱和市场进去做一些同质和微小提升的产品。</p><h4 id="信息区域性"><a href="#信息区域性" class="headerlink" title="信息区域性"></a>信息区域性</h4><p>当互联网把世界连结的时候，大家以为我们能够获得全世界的信息，事实上也确实这样，但我们只是获得了全世界信息里的几条或者十几条。从这种角度来讲，我们获取到了一些无用的信息，因为我们不是一国首脑。全世界七十亿人其实信息区域性是非常严重的。当然我们现在可能都会通过相同的门户网站去获取信息，但是不要忘了人群的区域性导致的我们在我们的朋友圈具有相当高的信息重合率。举个例子，我之前都以为百度贴吧都已经没了，但是我朋友却和我说他经常在上面逛，又比如每次我到网吧，看着一些中年男人玩着剧本类古风的角色扮演游戏，主要是和网友在那聊天，我就震惊，原来在互联网里的这么一个小角落仍然有一个小的社群。所以不要以为自己的信息非常全，我们的信息来自于我们的周边，而我们的周边又被人群区域性所阻断，所以我们很难知道别的人群是怎样的，难道我们的产品就是卖给我们这群人的么？观察世界上不同工作，不同收入，不同地方的人才是创业者应当做的。所以请打破心中的迷信和成见，请把自己当成井底之蛙，去空杯的了解你的目标客户，自行揣摩出来的结果都只是自己的意淫。</p><h4 id="认知的区域性"><a href="#认知的区域性" class="headerlink" title="认知的区域性"></a>认知的区域性</h4><p>我想认知的区域性是限制在我们每个人身上的，往大了说“朝菌不知晦朔，蟪蛄不知春秋”， 往小了说，我们可能和我们的朋友也不是完全相互理解的，有时候当然会觉得对方的举动令人费解，甚至纳闷，为什么会存在这样的人？推而广之，当我们的身边都是多金的投资人，名校毕业的创业者，牛导灌输的创业理念，我们的想法也会逐渐趋向于他们，会逐渐认为，创业者就是这样的，项目就是该这样做的，世界就是这样运转的。我倒不是说他们不对，而是说我们起码应该形成自己的思考，以自己为本去逐渐尝试推翻他们的理念，重要的不是到最后是否成功推翻，而是尝试推翻的理念和过程。他们也只是创业者中的一小撮人，如果以活下来的公司数量以及体量来看，非名校和本科毕业生应该是最多的，甚至在美国前十的富豪中，辍学者是最多的（甲骨文创始人言论）。创业导师和体系是社会发展到一定地步的衍生品，而在此之前呢，那些创业者都是自己打拼出来的，因此对事物都有自己的思考，看法和主见，这才是我认为最重要的，因为这样的人会一直在实战中成长下去，且成就可以远远超越这些老师们。那如何判断是否形成了自己的认知呢？我做的决定确实是我思考后做的决定，别人说的我也是觉得有道理才接纳的。我觉得有一点指导可以帮助我们判断，那就是是否怀疑这一切。</p><p>关于认知的局限性如何突破，如何扩大自己认知，以我目前的知识积累来看，只能说一句“功夫在别处”，“执象而求，咫尺千里”。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/04/04/Hello-World/"/>
      <url>/2022/04/04/Hello-World/</url>
      
        <content type="html"><![CDATA[<p>想安静下来整理一下这段时间的收获了，之前旧的博客仍旧留在 <a href="https://note.xblame.top/">https://note.xblame.top</a>。</p><p>简单修改了一下Coder这个hexo主题，感兴趣的话可以从我fork的仓库<a href="https://github.com/Blameying/Coder">Coder</a>获取</p><p>感谢Coder主题的作者所作出的工作!</p><p><img src="https://blog-img-1310827095.cos.ap-beijing.myqcloud.com/v2-398865f54c6c730aa3694400d2f98837_xl.jpg" alt="v2-398865f54c6c730aa3694400d2f98837_xl"></p>]]></content>
      
      
      <categories>
          
          <category> INIT </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
